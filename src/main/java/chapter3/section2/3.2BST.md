# 二叉查找树
+ **定义** 二叉查找树是一棵二叉树，其中每个结点都含有一个Comparable的键，且每个结点的键都大于其左子节点树中的任意结点而小于右子节点树的任意结点。
+ API（与符号表中的API基本相同）
  + 数据使用内部的嵌套类，该类包含键， 值， 左子结点指针，右子节点指针，结点计数器。
  + 查找 Value get（Key key）
    + 使用递归（或使用非递归）的方法，键小于根结点键时在左子节点找，大于时在右子节点找。找不到返回null
  + 插入 void put（Key key， Value value）
    + 于查找中的逻辑类似，键小于根的键在左子节点找，大于则在右子节点找。找到后插入值，并更新结点计数器。
  + 分析
    + 内部路径长度，将树中所有结点的深度加起来得到内部路径长度  
    + 最好情况，最坏情况，一般情况
      + 最好为完全二叉树，最坏为一条链表（按顺序或逆序的值进行插入），一般为介于两者之间（随机分布的插入时）
    + **命题C：** 由N个随机键构成的二叉查找树中，查找命中平均所需的比较次数为～2ln(N) 约 1.39lg(N)
    + **命题D：** 在由N个随机键构造的二叉查找树中插入操作未命中平均所需的比较次数～2ln(N) 约 1.39lg(N)
  + 最大键 Key max（）
    + 如果根结点的右子节点为空，则根结点为最大键，如果不为空，则是右子树中的最大键。
  + 最小键 Key min（）
    + 如果根结点的左子节点为空，则根结点为最小是，如果不为空，则是左子树中的最小值。
  + 向上取整与向下取整  Key ceiling（），  Key flooring（）
    + 如果给定的键 key小于二叉查找树的根结点的键，那么小于等于 key的最大键 floor( key)一定在根结点的左子树中；如果给定的键 key大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于 key的结点时，小于等于 key的最大键才会出现在右子树中，否则根结点就是小于等于 key的最大键。这段描述说明了 floor()方法的递归实现，同时也递推地证明了它能够计算出预期的结果。将“左”变为“右”（同时将小于变为大于）就能够得到 ceiling()的算法。
  + 选择操作， Key select（int i）
    + 假设我们想找到排名为 K 的键（即树中正好有个小于它的键）。如果左子树中的结点数 T ￼大于 K￼，那么我们就继续（递归地）在左子树中查找排名为 K￼的键；如果 T￼等于 K￼，我们就返回根结点中的键；如果T小于K，我们就（递归地）在右子树中查找排名为（ K-T-1￼）的键。
  + 排名 int rank（Key key）
    + 与选择操作类似，如果key小于根结点找到与key相同的结点后，返回左子节点树的结点数。如果大于根结点，则返回t（根结点左子节点数） + 1 + 右子结点树中与key相等的结点的左子节点数。
  + 删除最小键 void deleteMin（）
    +  如果根结点的左子结点为空，则删除根结点。返回根结点的右子结点。
    + 如果根结点的左子节点不为空，则一直找到左子节点为空的结点为空的结点为止，并返回删除结点的右子节点。
    + 更新结点数
  + 删除最大值 void deleteMax（）
    + 与删除最小值类只是将左子节点改为右子节点。
  + 删除操作 void delete（Key key）
    + 将要删除结点标记为变量t
    + 将x指向它的后继结点 min（t.right)
    + 将x的右链接指向deleteMin（t.right)
    + 将X的左连接设为t.left
  + 范围查找 
    + 使用中序遍历的变体，具体过程为，如果结点的键的范围内时，写入到队列中（其他也可，只要是实现了Iterable的类型）并返回
  + 性能分析
    + **命题E：**在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。
    + 在随机分布的二叉查找树中，树的平均高度了3lg（N），即**随机构造的树的所有路径长度为3lg（N）**
    + ![3.2 简单符号表在最坏情况下的总结](image/3.2%20简单符号表最坏情况下的实现总结.png "总结")
